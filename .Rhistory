} # for (i_sample in 1:n_sample)
# Step 3. P
# for (a in 1:K0){
#     for (b in a:K0){
#         sum_A_ij = sum_one_minus_A_ij = 0
#         for (i_sample in 1:(n-1)){
#             for (j_sample in (i_sample+1):n){
#                 if ( (zs[i_sample]==a)&(zs[j_sample]==b) ){
#                     sum_A_ij = sum_A_ij + A[i_sample,j_sample]
#                     sum_one_minus_A_ij = sum_one_minus_A_ij + (1-A[i_sample,j_sample])
#                 } # if ( (z_vec[i_sample]==a)&(z_vec[j_sample]==b) )
#             } # for (j_sample in (i_sample+1):n_sample)
#         } # for (i_sample in 1:n_sample)
#         beta1_star = b10 + sum_A_ij ; beta2_star = b20 + sum_one_minus_A_ij
#         #print(paste(a,b,sum_A_ij,sum_one_minus_A_ij))
#         Ps[a,b] = Ps[b,a] = rbeta(n=1,beta1_star,beta2_star)
#     } # for (b in (a+1):K)
# } # for (a in 1:(K-1))
Ps = update_P(A,zs,K0,b10,b20)
# Calculating P(z|Data) to find MAP
logf_z_given_A = 0
for (i_sample in 1:n){
logf_z_given_A = logf_z_given_A + log(pis[zs[i_sample]])
} # for (i_sample in 1:n_sample)
for (i_sample in 1:(n-1)){
for (j_sample in (i_sample+1):n){
logf_z_given_A = logf_z_given_A +
A[i_sample,j_sample]*log(Ps[zs[i_sample],zs[j_sample]]) +
(1.0-A[i_sample,j_sample])*log(1.0-Ps[zs[i_sample],zs[j_sample]])
} # for (j_sample in (i_sample+1):n_sample)
} # for (j_sample in (i_sample+1):n_sample)
# Store values
if(i > burn)
{
j = i - burn
Z[j,] = zs
PI[j,] = pis
PM[j,,] = Ps
draw_logf_z_given_A[j] = logf_z_given_A
}
# Print status
print(paste("Iteration",i))
#print(pis)
if ( round(i/100)==(i/100) ){
print( paste0("iter=",i) )
print( "pi_vec=" )
print( round(pis,3) )
}
}
run.time<-proc.time()-start.time
print(paste("Finished MCMC after",run.time[1],"seconds"))
start.time<-proc.time()
for (i in 1:n_iter){
# Step 1. pi
ns = table(zs)
as = ns + a0
pis = rdirichlet(n=1, as)
print(ns)
# Step 2. z
for (i_sample in 1:n){ # loop through all nodes
pi_star = rep(0,K0)
for (k in 1:K0){ # loop through all cluster
pi_star[k] = pis[k]
for (j_sample in c(1:n)[-i_sample]){ # loop through all nodes except i_sample
pi_star[k] = pi_star[k] *
(Ps[k,zs[j_sample]])^A[i_sample,j_sample] *
(1.0-Ps[k,zs[j_sample]])^(1-A[i_sample,j_sample])
} # for (j_sample in c(1:n_sample)[-i_sample])
} # for (k in 1:K)
pi_star = pi_star / sum(pi_star)
# print(pi_star)
zs[i_sample] = sample(x=(1:K0), size=1, prob=pi_star)
} # for (i_sample in 1:n_sample)
# Step 3. P
# for (a in 1:K0){
#     for (b in a:K0){
#         sum_A_ij = sum_one_minus_A_ij = 0
#         for (i_sample in 1:(n-1)){
#             for (j_sample in (i_sample+1):n){
#                 if ( (zs[i_sample]==a)&(zs[j_sample]==b) ){
#                     sum_A_ij = sum_A_ij + A[i_sample,j_sample]
#                     sum_one_minus_A_ij = sum_one_minus_A_ij + (1-A[i_sample,j_sample])
#                 } # if ( (z_vec[i_sample]==a)&(z_vec[j_sample]==b) )
#             } # for (j_sample in (i_sample+1):n_sample)
#         } # for (i_sample in 1:n_sample)
#         beta1_star = b10 + sum_A_ij ; beta2_star = b20 + sum_one_minus_A_ij
#         #print(paste(a,b,sum_A_ij,sum_one_minus_A_ij))
#         Ps[a,b] = Ps[b,a] = rbeta(n=1,beta1_star,beta2_star)
#     } # for (b in (a+1):K)
# } # for (a in 1:(K-1))
Ps = update_P(A,zs,K0,b10,b20)
# Calculating P(z|Data) to find MAP
logf_z_given_A = 0
for (i_sample in 1:n){
logf_z_given_A = logf_z_given_A + log(pis[zs[i_sample]])
} # for (i_sample in 1:n_sample)
for (i_sample in 1:(n-1)){
for (j_sample in (i_sample+1):n){
logf_z_given_A = logf_z_given_A +
A[i_sample,j_sample]*log(Ps[zs[i_sample],zs[j_sample]]) +
(1.0-A[i_sample,j_sample])*log(1.0-Ps[zs[i_sample],zs[j_sample]])
} # for (j_sample in (i_sample+1):n_sample)
} # for (j_sample in (i_sample+1):n_sample)
# Store values
if(i > burn)
{
j = i - burn
Z[j,] = zs
PI[j,] = pis
PM[j,,] = Ps
draw_logf_z_given_A[j] = logf_z_given_A
}
# Print status
print(paste("Iteration",i))
#print(pis)
if ( round(i/100)==(i/100) ){
print( paste0("iter=",i) )
print( "pi_vec=" )
print( round(pis,3) )
}
}
run.time<-proc.time()-start.time
print(paste("Finished MCMC after",run.time[1],"seconds"))
start.time<-proc.time()
for (i in 1:n_iter){
# Step 1. pi
ns = table(zs)
as = ns + a0
pis = rdirichlet(n=1, as)
print(ns)
# Step 2. z
for (i_sample in 1:n){ # loop through all nodes
pi_star = rep(0,K0)
for (k in 1:K0){ # loop through all cluster
pi_star[k] = pis[k]
for (j_sample in c(1:n)[-i_sample]){ # loop through all nodes except i_sample
pi_star[k] = pi_star[k] *
(Ps[k,zs[j_sample]])^A[i_sample,j_sample] *
(1.0-Ps[k,zs[j_sample]])^(1-A[i_sample,j_sample])
} # for (j_sample in c(1:n_sample)[-i_sample])
} # for (k in 1:K)
pi_star = pi_star / sum(pi_star)
# print(pi_star)
zs[i_sample] = sample(x=(1:K0), size=1, prob=pi_star)
} # for (i_sample in 1:n_sample)
# Step 3. P
# for (a in 1:K0){
#     for (b in a:K0){
#         sum_A_ij = sum_one_minus_A_ij = 0
#         for (i_sample in 1:(n-1)){
#             for (j_sample in (i_sample+1):n){
#                 if ( (zs[i_sample]==a)&(zs[j_sample]==b) ){
#                     sum_A_ij = sum_A_ij + A[i_sample,j_sample]
#                     sum_one_minus_A_ij = sum_one_minus_A_ij + (1-A[i_sample,j_sample])
#                 } # if ( (z_vec[i_sample]==a)&(z_vec[j_sample]==b) )
#             } # for (j_sample in (i_sample+1):n_sample)
#         } # for (i_sample in 1:n_sample)
#         beta1_star = b10 + sum_A_ij ; beta2_star = b20 + sum_one_minus_A_ij
#         #print(paste(a,b,sum_A_ij,sum_one_minus_A_ij))
#         Ps[a,b] = Ps[b,a] = rbeta(n=1,beta1_star,beta2_star)
#     } # for (b in (a+1):K)
# } # for (a in 1:(K-1))
Ps = update_P(A,zs,K0,b10,b20)
# Calculating P(z|Data) to find MAP
logf_z_given_A = 0
for (i_sample in 1:n){
logf_z_given_A = logf_z_given_A + log(pis[zs[i_sample]])
} # for (i_sample in 1:n_sample)
for (i_sample in 1:(n-1)){
for (j_sample in (i_sample+1):n){
logf_z_given_A = logf_z_given_A +
A[i_sample,j_sample]*log(Ps[zs[i_sample],zs[j_sample]]) +
(1.0-A[i_sample,j_sample])*log(1.0-Ps[zs[i_sample],zs[j_sample]])
} # for (j_sample in (i_sample+1):n_sample)
} # for (j_sample in (i_sample+1):n_sample)
# Store values
if(i > burn)
{
j = i - burn
Z[j,] = zs
PI[j,] = pis
PM[j,,] = Ps
draw_logf_z_given_A[j] = logf_z_given_A
}
# Print status
print(paste("Iteration",i))
#print(pis)
if ( round(i/100)==(i/100) ){
print( paste0("iter=",i) )
print( "pi_vec=" )
print( round(pis,3) )
}
}
run.time<-proc.time()-start.time
print(paste("Finished MCMC after",run.time[1],"seconds"))
start.time<-proc.time()
for (i in 1:n_iter){
# Step 1. pi
ns = table(zs)
as = ns + a0
pis = rdirichlet(n=1, as)
print(ns)
# Step 2. z
for (i_sample in 1:n){ # loop through all nodes
pi_star = rep(0,K0)
for (k in 1:K0){ # loop through all cluster
pi_star[k] = pis[k]
for (j_sample in c(1:n)[-i_sample]){ # loop through all nodes except i_sample
pi_star[k] = pi_star[k] *
(Ps[k,zs[j_sample]])^A[i_sample,j_sample] *
(1.0-Ps[k,zs[j_sample]])^(1-A[i_sample,j_sample])
} # for (j_sample in c(1:n_sample)[-i_sample])
} # for (k in 1:K)
pi_star = pi_star / sum(pi_star)
# print(pi_star)
zs[i_sample] = sample(x=(1:K0), size=1, prob=pi_star)
} # for (i_sample in 1:n_sample)
# Step 3. P
# for (a in 1:K0){
#     for (b in a:K0){
#         sum_A_ij = sum_one_minus_A_ij = 0
#         for (i_sample in 1:(n-1)){
#             for (j_sample in (i_sample+1):n){
#                 if ( (zs[i_sample]==a)&(zs[j_sample]==b) ){
#                     sum_A_ij = sum_A_ij + A[i_sample,j_sample]
#                     sum_one_minus_A_ij = sum_one_minus_A_ij + (1-A[i_sample,j_sample])
#                 } # if ( (z_vec[i_sample]==a)&(z_vec[j_sample]==b) )
#             } # for (j_sample in (i_sample+1):n_sample)
#         } # for (i_sample in 1:n_sample)
#         beta1_star = b10 + sum_A_ij ; beta2_star = b20 + sum_one_minus_A_ij
#         #print(paste(a,b,sum_A_ij,sum_one_minus_A_ij))
#         Ps[a,b] = Ps[b,a] = rbeta(n=1,beta1_star,beta2_star)
#     } # for (b in (a+1):K)
# } # for (a in 1:(K-1))
Ps = update_P(A,zs,K0,b10,b20)
# Calculating P(z|Data) to find MAP
logf_z_given_A = 0
for (i_sample in 1:n){
logf_z_given_A = logf_z_given_A + log(pis[zs[i_sample]])
} # for (i_sample in 1:n_sample)
for (i_sample in 1:(n-1)){
for (j_sample in (i_sample+1):n){
logf_z_given_A = logf_z_given_A +
A[i_sample,j_sample]*log(Ps[zs[i_sample],zs[j_sample]]) +
(1.0-A[i_sample,j_sample])*log(1.0-Ps[zs[i_sample],zs[j_sample]])
} # for (j_sample in (i_sample+1):n_sample)
} # for (j_sample in (i_sample+1):n_sample)
# Store values
if(i > burn)
{
j = i - burn
Z[j,] = zs
PI[j,] = pis
PM[j,,] = Ps
draw_logf_z_given_A[j] = logf_z_given_A
}
# Print status
print(paste("Iteration",i))
#print(pis)
if ( round(i/100)==(i/100) ){
print( paste0("iter=",i) )
print( "pi_vec=" )
print( round(pis,3) )
}
}
run.time<-proc.time()-start.time
print(paste("Finished MCMC after",run.time[1],"seconds"))
start.time<-proc.time()
for (i in 1:n_iter){
# Step 1. pi
ns = table(zs)
as = ns + a0
pis = rdirichlet(n=1, as)
print(ns)
# Step 2. z
for (i_sample in 1:n){ # loop through all nodes
pi_star = rep(0,K0)
for (k in 1:K0){ # loop through all cluster
pi_star[k] = pis[k]
for (j_sample in c(1:n)[-i_sample]){ # loop through all nodes except i_sample
pi_star[k] = pi_star[k] *
(Ps[k,zs[j_sample]])^A[i_sample,j_sample] *
(1.0-Ps[k,zs[j_sample]])^(1-A[i_sample,j_sample])
} # for (j_sample in c(1:n_sample)[-i_sample])
} # for (k in 1:K)
pi_star = pi_star / sum(pi_star)
# print(pi_star)
zs[i_sample] = sample(x=(1:K0), size=1, prob=pi_star)
} # for (i_sample in 1:n_sample)
# Step 3. P
# for (a in 1:K0){
#     for (b in a:K0){
#         sum_A_ij = sum_one_minus_A_ij = 0
#         for (i_sample in 1:(n-1)){
#             for (j_sample in (i_sample+1):n){
#                 if ( (zs[i_sample]==a)&(zs[j_sample]==b) ){
#                     sum_A_ij = sum_A_ij + A[i_sample,j_sample]
#                     sum_one_minus_A_ij = sum_one_minus_A_ij + (1-A[i_sample,j_sample])
#                 } # if ( (z_vec[i_sample]==a)&(z_vec[j_sample]==b) )
#             } # for (j_sample in (i_sample+1):n_sample)
#         } # for (i_sample in 1:n_sample)
#         beta1_star = b10 + sum_A_ij ; beta2_star = b20 + sum_one_minus_A_ij
#         #print(paste(a,b,sum_A_ij,sum_one_minus_A_ij))
#         Ps[a,b] = Ps[b,a] = rbeta(n=1,beta1_star,beta2_star)
#     } # for (b in (a+1):K)
# } # for (a in 1:(K-1))
Ps = update_P(A,zs,K0,b10,b20)
# Calculating P(z|Data) to find MAP
logf_z_given_A = 0
for (i_sample in 1:n){
logf_z_given_A = logf_z_given_A + log(pis[zs[i_sample]])
} # for (i_sample in 1:n_sample)
for (i_sample in 1:(n-1)){
for (j_sample in (i_sample+1):n){
logf_z_given_A = logf_z_given_A +
A[i_sample,j_sample]*log(Ps[zs[i_sample],zs[j_sample]]) +
(1.0-A[i_sample,j_sample])*log(1.0-Ps[zs[i_sample],zs[j_sample]])
} # for (j_sample in (i_sample+1):n_sample)
} # for (j_sample in (i_sample+1):n_sample)
# Store values
if(i > burn)
{
j = i - burn
Z[j,] = zs
PI[j,] = pis
PM[j,,] = Ps
draw_logf_z_given_A[j] = logf_z_given_A
}
# Print status
print(paste("Iteration",i))
#print(pis)
if ( round(i/100)==(i/100) ){
print( paste0("iter=",i) )
print( "pi_vec=" )
print( round(pis,3) )
}
}
run.time<-proc.time()-start.time
print(paste("Finished MCMC after",run.time[1],"seconds"))
start.time<-proc.time()
for (i in 1:n_iter){
# Step 1. pi
ns = table(zs)
as = ns + a0
pis = rdirichlet(n=1, as)
print(ns)
# Step 2. z
for (i_sample in 1:n){ # loop through all nodes
pi_star = rep(0,K0)
for (k in 1:K0){ # loop through all cluster
pi_star[k] = pis[k]
for (j_sample in c(1:n)[-i_sample]){ # loop through all nodes except i_sample
pi_star[k] = pi_star[k] *
(Ps[k,zs[j_sample]])^A[i_sample,j_sample] *
(1.0-Ps[k,zs[j_sample]])^(1-A[i_sample,j_sample])
} # for (j_sample in c(1:n_sample)[-i_sample])
} # for (k in 1:K)
pi_star = pi_star / sum(pi_star)
# print(pi_star)
zs[i_sample] = sample(x=(1:K0), size=1, prob=pi_star)
} # for (i_sample in 1:n_sample)
# Step 3. P
# for (a in 1:K0){
#     for (b in a:K0){
#         sum_A_ij = sum_one_minus_A_ij = 0
#         for (i_sample in 1:(n-1)){
#             for (j_sample in (i_sample+1):n){
#                 if ( (zs[i_sample]==a)&(zs[j_sample]==b) ){
#                     sum_A_ij = sum_A_ij + A[i_sample,j_sample]
#                     sum_one_minus_A_ij = sum_one_minus_A_ij + (1-A[i_sample,j_sample])
#                 } # if ( (z_vec[i_sample]==a)&(z_vec[j_sample]==b) )
#             } # for (j_sample in (i_sample+1):n_sample)
#         } # for (i_sample in 1:n_sample)
#         beta1_star = b10 + sum_A_ij ; beta2_star = b20 + sum_one_minus_A_ij
#         #print(paste(a,b,sum_A_ij,sum_one_minus_A_ij))
#         Ps[a,b] = Ps[b,a] = rbeta(n=1,beta1_star,beta2_star)
#     } # for (b in (a+1):K)
# } # for (a in 1:(K-1))
Ps = update_P(A,zs,K0,b10,b20)
# Calculating P(z|Data) to find MAP
logf_z_given_A = 0
for (i_sample in 1:n){
logf_z_given_A = logf_z_given_A + log(pis[zs[i_sample]])
} # for (i_sample in 1:n_sample)
for (i_sample in 1:(n-1)){
for (j_sample in (i_sample+1):n){
logf_z_given_A = logf_z_given_A +
A[i_sample,j_sample]*log(Ps[zs[i_sample],zs[j_sample]]) +
(1.0-A[i_sample,j_sample])*log(1.0-Ps[zs[i_sample],zs[j_sample]])
} # for (j_sample in (i_sample+1):n_sample)
} # for (j_sample in (i_sample+1):n_sample)
# Store values
if(i > burn)
{
j = i - burn
Z[j,] = zs
PI[j,] = pis
PM[j,,] = Ps
draw_logf_z_given_A[j] = logf_z_given_A
}
# Print status
print(paste("Iteration",i))
#print(pis)
if ( round(i/100)==(i/100) ){
print( paste0("iter=",i) )
print( "pi_vec=" )
print( round(pis,3) )
}
}
run.time<-proc.time()-start.time
print(paste("Finished MCMC after",run.time[1],"seconds"))
start.time<-proc.time()
for (i in 1:n_iter){
# Step 1. pi
ns = table(zs)
as = ns + a0
pis = rdirichlet(n=1, as)
print(ns)
# Step 2. z
for (i_sample in 1:n){ # loop through all nodes
pi_star = rep(0,K0)
for (k in 1:K0){ # loop through all cluster
pi_star[k] = pis[k]
for (j_sample in c(1:n)[-i_sample]){ # loop through all nodes except i_sample
pi_star[k] = pi_star[k] *
(Ps[k,zs[j_sample]])^A[i_sample,j_sample] *
(1.0-Ps[k,zs[j_sample]])^(1-A[i_sample,j_sample])
} # for (j_sample in c(1:n_sample)[-i_sample])
} # for (k in 1:K)
pi_star = pi_star / sum(pi_star)
# print(pi_star)
zs[i_sample] = sample(x=(1:K0), size=1, prob=pi_star)
} # for (i_sample in 1:n_sample)
# Step 3. P
# for (a in 1:K0){
#     for (b in a:K0){
#         sum_A_ij = sum_one_minus_A_ij = 0
#         for (i_sample in 1:(n-1)){
#             for (j_sample in (i_sample+1):n){
#                 if ( (zs[i_sample]==a)&(zs[j_sample]==b) ){
#                     sum_A_ij = sum_A_ij + A[i_sample,j_sample]
#                     sum_one_minus_A_ij = sum_one_minus_A_ij + (1-A[i_sample,j_sample])
#                 } # if ( (z_vec[i_sample]==a)&(z_vec[j_sample]==b) )
#             } # for (j_sample in (i_sample+1):n_sample)
#         } # for (i_sample in 1:n_sample)
#         beta1_star = b10 + sum_A_ij ; beta2_star = b20 + sum_one_minus_A_ij
#         #print(paste(a,b,sum_A_ij,sum_one_minus_A_ij))
#         Ps[a,b] = Ps[b,a] = rbeta(n=1,beta1_star,beta2_star)
#     } # for (b in (a+1):K)
# } # for (a in 1:(K-1))
Ps = update_P(A,zs,K0,b10,b20)
# Calculating P(z|Data) to find MAP
logf_z_given_A = 0
for (i_sample in 1:n){
logf_z_given_A = logf_z_given_A + log(pis[zs[i_sample]])
} # for (i_sample in 1:n_sample)
for (i_sample in 1:(n-1)){
for (j_sample in (i_sample+1):n){
logf_z_given_A = logf_z_given_A +
A[i_sample,j_sample]*log(Ps[zs[i_sample],zs[j_sample]]) +
(1.0-A[i_sample,j_sample])*log(1.0-Ps[zs[i_sample],zs[j_sample]])
} # for (j_sample in (i_sample+1):n_sample)
} # for (j_sample in (i_sample+1):n_sample)
# Store values
if(i > burn)
{
j = i - burn
Z[j,] = zs
PI[j,] = pis
PM[j,,] = Ps
draw_logf_z_given_A[j] = logf_z_given_A
}
# Print status
print(paste("Iteration",i))
#print(pis)
if ( round(i/100)==(i/100) ){
print( paste0("iter=",i) )
print( "pi_vec=" )
print( round(pis,3) )
}
}
run.time<-proc.time()-start.time
print(paste("Finished MCMC after",run.time[1],"seconds"))
source('~/Documents/Research/Code/sbm_R/simulation.R')
diag(A)
source('~/Documents/Research/Code/sbm_R/simulation.R')
source('~/Documents/Research/Code/sbm_R/simulation.R')
source('~/Documents/Research/Code/sbm_R/simulation.R')
source('~/Documents/Research/Code/sbm_R/simulation.R')
source('~/Documents/Research/Code/sbm_R/simulation.R')
source('~/Documents/Research/Code/sbm_R/simulation.R')
source('~/Documents/Research/Code/sbm_R/simulation.R')
source('~/Documents/Research/Code/sbm_R/simulation.R')
source('~/Documents/Research/Code/sbm_R/simulation.R')
Rcpp::sourceCpp('update_z.cpp')
update_z(zs,A,pis,Ps,K0,1:K0)
update_z(zs,A,pis,Ps,K0,1:K0)
update_z(zs,A,pis,Ps,K0,1:K0)
update_z(zs,A,pis,Ps,K0,1:K0)
update_z(zs,A,pis,Ps,K0,1:K0)
update_z(zs,A,pis,Ps,K0,1:K0)
update_z(zs,A,pis,Ps,K0,1:K0)
Rcpp::sourceCpp('update_z.cpp')
update_z(zs,A,pis,Ps,K0,1:K0)
Rcpp::sourceCpp('update_z.cpp')
Rcpp::sourceCpp('update_z.cpp')
Rcpp::sourceCpp('update_z.cpp')
update_z(zs,A,pis,Ps,K0,1:K0)
update_z(zs,A,pis,Ps,K0,1:K0)
Rcpp::sourceCpp('update_z.cpp')
update_z(zs,A,pis,Ps,K0,1:K0)
update_z(zs,A,pis,Ps,K0,1:K0)
