install.packages("brms")
library(brms)
fit1 <- brm(count ~ zAge + zBase * Trt + (1|patient),
data = epilepsy, family = poisson())
summary(fit1)
plot(fit1, pars = c("Trt", "zBase"))
stancode(fit1)
fit1 <- brm(count ~ zAge + zBase * Trt + (1|patient),
data = epilepsy, family = poisson())
epilepsy
library(igraph)
library(igraphdata)
igraphdata
karate
igraphdata:::karate
karate
data("karate")
karate
as_edgelist(karate)
k_edges <- as_edgelist(karate)
library(tidyverse)
k_edges <- as_edgelist(karate) %>% as.data.frame()
View(k_edges)
colnames(k_edges) <- c("V1","V2")
source('~/Documents/School/Fall_2019/Research/Code/karate_edge_list.R')
View(k_edges)
write.csv("Data/karate_edge_list.csv")
write.csv(k_edges,
"Data/karate_edge_list.csv",
quote = FALSE,
row.names = FALSE)
unique(c(k_edges$V1,k_edges$V2))
k_edges$V1
unique(c(as.character(k_edges$V1),as.character(k_edges$V2)))
length(unique(c(as.character(k_edges$V1),as.character(k_edges$V2))))
data("karate")
karate
library(sbmlogit)
install.packages("GPA")
install.packages("devtools")
library(devtools)
install_github("dongjunchung/GGPA")
install_github("dongjunchung/GPA")
install_github("dongjunchung/GGPA")
install.packages("BiocManager")
BiocManager::install()
''
library(devtools)
install_github("dongjunchung/GGPA")
BiocManager::install()
BiocManager::install()
install.packages(c("coda", "ggraph", "igraph", "igraphdata", "tidygraph"))
install.packages("~/Documents/School/Research/Code/sbm-code/sbmlogit.tar.gz", repos = NULL, type = "source")
knitr::opts_chunk$set(echo = TRUE,message = FALSE,warning = FALSE,cache = TRUE)
library(igraph)
library(igraphdata)
library(sbmlogit)
library(sbmlhelpers)
library(devtools)
install_github("carter-allen/sbmlhelpers")
library(igraph)
library(igraphdata)
library(sbmlogit)
library(sbmlhelpers)
library(ggraph)
library(tidygraph)
library(tidyverse)
library(coda)
install.packages("~/Downloads/BiocCheck_1.4.0.tgz", repos = NULL, type = .Platform$pkgType)
library(BiocCheck)
install.packages("optparse")
library(BiocCheck)
install.packages("BiocInstaller")
install.packages("~/Downloads/BiocInstaller_1.32.1.tgz", repos = NULL, type = .Platform$pkgType)
library(BiocCheck)
BiocManager::install("biocViews")
library(BiocCheck)
install.packages("SmCCNet")
vignette(package = "SmCCNet")
library(SmCCNet)
knitr::opts_chunk$set(echo = TRUE)
library(SmCCNet)
library(sbmlogit)
library(PMA)
library(pbapply)
library(Matrix)
library(igraph)
library(SmCCNet)
library(sbmlogit)
getwd
getwd()
load("Code/SmCCNet-master/data/ExampleData.Rdata")
load("Code/SmCCNet-master/data/ExampleData.Rdata")
load("Code/SmCCNet-master/data/ExampleData.Rdata")
getwd()
setwd("/Users/carterallen/Documents/School/Research")
load("Code/SmCCNet-master/data/ExampleData.Rdata")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/carterallen/Documents/School/Research")
library(PMA)
library(pbapply)
library(Matrix)
library(igraph)
library(SmCCNet)
library(sbmlogit)
load("Code/SmCCNet-master/data/ExampleData.Rdata")
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics("SmCCNetWorkflow.pdf")
suppressPackageStartupMessages({
library(PMA)
library(pbapply)
library(Matrix)
library(igraph)
})
library(PMA)
library(pbapply)
library(Matrix)
library(igraph)
source("../R/ModifiedPMA.R")
source("../R/SmCCNetSource.R")
load("../data/ExampleData.RData")
head(X1[ , 1:6])
head(X2[ , 1:6])
head(Y)
p1 <- ncol(X1)
p2 <- ncol(X2)
n <- nrow(X1)
AbarLabel <- c(colnames(cbind(X1, X2)))
knitr::include_graphics("SmCCNetCV.pdf")
K <- 3 # Number of folds in K-fold CV.
CCcoef <- NULL # Unweighted version of SmCCNet.
s1 <- 0.7; s2 <- 0.9 # Feature sampling proportions.
SubsamplingNum <- 500 # Number of subsamples.
# Create sparsity penalty options.
pen1 <- seq(.05, .3, by = .05)
pen2 <- seq(.05, .3, by = .05)
P1P2 <- expand.grid(pen1, pen2)
# Map (l1, l2) to (c1, c2).
c1 <- sqrt(p1 * s1) * P1P2[ , 1]; c1[c1] <- 1
c2 <- sqrt(p2 * s2) * P1P2[ , 2]; c2[c2 < 1] <- 1
# Based on prior knowledge we may assume that there are at least as many genes
# as miRNAs in each network.
P1P2 <- P1P2[which(c1>c2), ]
# Set a CV directory.
CVDir <- "Example3foldCV/"
dir.create(CVDir)
set.seed(12345) # Set random seed.
foldIdx <- split(1:n, sample(1:n, K))
for(i in 1:K){
iIdx <- foldIdx[[i]]
x1.train <- scale(X1[-iIdx, ])
x2.train <- scale(X2[-iIdx, ])
yy.train <- scale(Y[-iIdx, ])
x1.test <- scale(X1[iIdx, ])
x2.test <- scale(X2[iIdx, ])
yy.test <- scale(Y[iIdx, ])
# Check if standardized data sets are valid.
if(is.na(min(min(x1.train), min(x2.train), min(yy.train), min(x1.test),
min(x2.test), min(yy.test)))){
stop("Invalid scaled data. At least one of the data matrices include a
column with zero variance.")
}
subD <- paste0(CVDir, "CV_", i, "/")
dir.create(subD)
save(x1.train, x2.train, yy.train, x1.test, x2.test, yy.test,
s1, s2, P1P2, p1, p2, SubsamplingNum, CCcoef,
file = paste0(subD, "Data.RData"))
}
library(parallel)
cl <- makeCluster(K, type = "FORK") # Create K parallel threads.
clusterExport(cl = cl, "CVDir") # Pass on variable CVDir to each thread.
parSapply(cl, 1:K, function(CVidx){
# Reload source code files for each thread.
source("../R/ModifiedPMA.R")
source("../R/SmCCNetSource.R")
# Create a result directory for each thread.
subD <- paste0(CVDir, "CV_", CVidx, "/")
load(paste0(subD, "Data.RData"))
dir.create(paste0(subD, "SmCCA/"))
RhoTrain <- RhoTest <- DeltaCor <- rep(0, nrow(P1P2))
for(idx in 1:nrow(P1P2)){
# Consider one pair of sparsity penalties at a time.
l1 <- P1P2[idx, 1]
l2 <- P1P2[idx, 2]
# Run SmCCA on the subsamples (Figure 1, Step II)
Ws <- getRobustPseudoWeights(x1.train, x2.train, yy.train, l1, l2,
s1, s2, NoTrait = FALSE,
FilterByTrait = FALSE,
SubsamplingNum = SubsamplingNum,
CCcoef = CCcoef)
# Aggregate pseudo-canonical weights from the subsamples.
meanW <- rowMeans(Ws)
v <- meanW[1:p1]
u <- meanW[p1 + 1:p2]
# Compute the prediction error for given CV fold and sparsity penalties.
if(is.null(CCcoef)){CCcoef <- rep(1, 3)} # Unweighted SmCCA.
rho.train <- cor(x1.train %*% v, x2.train %*% u) * CCcoef[1] +
cor(x1.train %*% v, yy.train) * CCcoef[2] +
cor(x2.train %*% u, yy.train) * CCcoef[3]
rho.test <- cor(x1.test %*% v, x2.test %*% u) * CCcoef[1] +
cor(x1.test %*% v, yy.test) * CCcoef[2] +
cor(x2.test %*% u, yy.test) * CCcoef[3]
RhoTrain[idx] <- round(rho.train, digits = 5)
RhoTest[idx] <- round(rho.test, digits = 5)
DeltaCor[idx] <- abs(rho.train - rho.test)
# Periodically save results in a temporary file.
if(idx %% 10 == 0){
save(P1P2, RhoTrain, RhoTest, DeltaCor, idx,
file = paste0(subD, "temp.RData"))
}
}
# Record prediction errors for given CV fold and all sparsity penalty
# options.
DeltaCor.all <- cbind(P1P2, RhoTrain, RhoTest, DeltaCor)
colnames(DeltaCor.all) <- c("l1", "l2", "Training CC", "Test CC",
"CC Pred. Error")
write.csv(DeltaCor.all,
file = paste0(subD, "SmCCA/PredictionError.csv"))
# Remove the temporary file.
system(paste0("rm ", subD, "temp.RData"))
return(CVidx)
})
BiocManager::install("WGCNA")
getwd()
dem <- read.csv("Data/demo_data_small.csv")
dem_mat <- as.matrix(dem)
var(dem)
cor(dem)
cor_mat <- cor(dem)
View(cor_mat)
lower.tri(cor_mat)
vec(lower.tri(cor_mat))
c(lower.tri(cor_mat))
c(cor_mat)[c(lower.tri(cor_mat))]
c(cor_mat)[c(lower.tri(cor_mat))]
quantile(c(cor_mat)[c(lower.tri(cor_mat))],probs = c(0.025,0.975))
install.packages("binda")
library(binda)
dichotomize(cor_mat,0.2275)
cor_mat2 <- dichotomize(cor_mat,0.2275)
View(cor_mat2)
cor_mat2 <- dichotomize(cor_mat,0.20)
View(cor_mat2)
isSymmetric(cor_mat2)
bioData <- read.csv("http://msekce.karlin.mff.cuni.cz/~maciak/NMST539/bioData.csv", header = T)
chemData <- read.csv("http://msekce.karlin.mff.cuni.cz/~maciak/NMST539/chemData.csv", header = T)
install.packages("CCA")
ind <- match(chemData[,1], bioData[,1])
data <- data.frame(bioData[ind, ], chemData[, 2:8])
View(data)
X <- data[,2:9]
Y <- data[,19:25]
library("CCA")
correl <- matcor(X, Y )
img.matcor(correl, type = 2)
cc1 <- cancor(X, Y)  ### function from standard R instalation
cc2 <- cc(X, Y)      ### function for the R package 'CCA'
knitr::opts_chunk$set(echo = TRUE)
suppressPackageStartupMessages({
library(PMA)
library(pbapply)
library(Matrix)
library(igraph)
})
library(PMA)
library(pbapply)
library(Matrix)
library(igraph)
source("../R/ModifiedPMA.R")
source("../R/SmCCNetSource.R")
load("../data/ExampleData.RData")
head(X1[ , 1:6])
head(X2[ , 1:6])
head(Y)
p1 <- ncol(X1)
p2 <- ncol(X2)
n <- nrow(X1)
AbarLabel <- c(colnames(cbind(X1, X2)))
K <- 2 # Number of folds in K-fold CV.
CCcoef <- NULL # Unweighted version of SmCCNet.
s1 <- 0.7; s2 <- 0.9 # Feature sampling proportions.
SubsamplingNum <- 50 # Number of subsamples.
# Create sparsity penalty options.
pen1 <- seq(.05, .3, by = .05)
pen2 <- seq(.05, .3, by = .05)
P1P2 <- expand.grid(pen1, pen2)
# Map (l1, l2) to (c1, c2).
c1 <- sqrt(p1 * s1) * P1P2[ , 1]; c1[c1] <- 1
c2 <- sqrt(p2 * s2) * P1P2[ , 2]; c2[c2 < 1] <- 1
# Based on prior knowledge we may assume that there are at least as many genes
# as miRNAs in each network.
P1P2 <- P1P2[which(c1>c2), ]
# Set a CV directory.
CVDir <- "Example3foldCV/"
dir.create(CVDir)
n
set.seed(12345) # Set random seed.
foldIdx <- split(1:n, sample(1:n, K))
for(i in 1:K){
iIdx <- foldIdx[[i]]
x1.train <- scale(X1[-iIdx, ])
x2.train <- scale(X2[-iIdx, ])
yy.train <- scale(Y[-iIdx, ])
x1.test <- scale(X1[iIdx, ])
x2.test <- scale(X2[iIdx, ])
yy.test <- scale(Y[iIdx, ])
# Check if standardized data sets are valid.
if(is.na(min(min(x1.train), min(x2.train), min(yy.train), min(x1.test),
min(x2.test), min(yy.test)))){
stop("Invalid scaled data. At least one of the data matrices include a
column with zero variance.")
}
subD <- paste0(CVDir, "CV_", i, "/")
dir.create(subD)
save(x1.train, x2.train, yy.train, x1.test, x2.test, yy.test,
s1, s2, P1P2, p1, p2, SubsamplingNum, CCcoef,
file = paste0(subD, "Data.RData"))
}
library(parallel)
cl <- makeCluster(K, type = "FORK") # Create K parallel threads.
clusterExport(cl = cl, "CVDir") # Pass on variable CVDir to each thread.
parSapply(cl, 1:K, function(CVidx){
# Reload source code files for each thread.
source("../R/ModifiedPMA.R")
source("../R/SmCCNetSource.R")
# Create a result directory for each thread.
subD <- paste0(CVDir, "CV_", CVidx, "/")
load(paste0(subD, "Data.RData"))
dir.create(paste0(subD, "SmCCA/"))
RhoTrain <- RhoTest <- DeltaCor <- rep(0, nrow(P1P2))
for(idx in 1:nrow(P1P2)){
# Consider one pair of sparsity penalties at a time.
l1 <- P1P2[idx, 1]
l2 <- P1P2[idx, 2]
# Run SmCCA on the subsamples (Figure 1, Step II)
Ws <- getRobustPseudoWeights(x1.train, x2.train, yy.train, l1, l2,
s1, s2, NoTrait = FALSE,
FilterByTrait = FALSE,
SubsamplingNum = SubsamplingNum,
CCcoef = CCcoef)
# Aggregate pseudo-canonical weights from the subsamples.
meanW <- rowMeans(Ws)
v <- meanW[1:p1]
u <- meanW[p1 + 1:p2]
# Compute the prediction error for given CV fold and sparsity penalties.
if(is.null(CCcoef)){CCcoef <- rep(1, 3)} # Unweighted SmCCA.
rho.train <- cor(x1.train %*% v, x2.train %*% u) * CCcoef[1] +
cor(x1.train %*% v, yy.train) * CCcoef[2] +
cor(x2.train %*% u, yy.train) * CCcoef[3]
rho.test <- cor(x1.test %*% v, x2.test %*% u) * CCcoef[1] +
cor(x1.test %*% v, yy.test) * CCcoef[2] +
cor(x2.test %*% u, yy.test) * CCcoef[3]
RhoTrain[idx] <- round(rho.train, digits = 5)
RhoTest[idx] <- round(rho.test, digits = 5)
DeltaCor[idx] <- abs(rho.train - rho.test)
# Periodically save results in a temporary file.
if(idx %% 10 == 0){
save(P1P2, RhoTrain, RhoTest, DeltaCor, idx,
file = paste0(subD, "temp.RData"))
}
}
# Record prediction errors for given CV fold and all sparsity penalty
# options.
DeltaCor.all <- cbind(P1P2, RhoTrain, RhoTest, DeltaCor)
colnames(DeltaCor.all) <- c("l1", "l2", "Training CC", "Test CC",
"CC Pred. Error")
write.csv(DeltaCor.all,
file = paste0(subD, "SmCCA/PredictionError.csv"))
# Remove the temporary file.
system(paste0("rm ", subD, "temp.RData"))
return(CVidx)
})
