library(ggraph)
library(tidygraph)
library(tidyverse)
data("karate")
fitK2 <- sbmlogit.mcmc(graph = karate,alpha = 2,nsamples = 2000)
# Function for estimator
mp = function(vec, K){
v = rep(1:K)
l = length(vec)
for (i in 1:K){
v[i] = sum(vec==i)/l
}
return(v)
}
SigmaK2 <- fitK2$sample # posterior samples
sigmaK2 <- apply(t(apply(SigmaK2, 2, mp, 2)), 1, which.max) # posterior estimator
scentroidK2 <- sbmlogit.remap(sigmaK2) # remapped posterior estimator
print(scentroidK2)
# function to compute WAIC
# verify this is correct
waic <- function(fit,burn = 0)
{
S <- length(fit$lhood)
ls <- exp(fit$lhood[(burn+1):S])
w <- 2*(log(mean(ls)) - mean(log(ls)))
return(w)
}
fitK3 <- sbmlogit.mcmc(graph = karate,alpha = 3,nsamples = 1000)
fitK4 <- sbmlogit.mcmc(graph = karate,alpha = 4,nsamples = 1000)
fitK5 <- sbmlogit.mcmc(graph = karate,alpha = 5,nsamples = 1000)
waic(fitK2, burn = 100)
waic(fitK3, burn = 100)
waic(fitK4, burn = 100)
waic(fitK5, burn = 100)
lls_df <- as.data.frame(cbind(fitK2$lhood,fitK3$lhood,fitK4$lhood,fitK5$lhood))
colnames(lls_df) <- c("K2","K3","K4","K5")
lls_df <- lls_df %>%
gather(key = "Model", value = "ll")
ggplot(data = lls_df,
aes(x = ll)) +
geom_histogram(bins = 30) +
facet_wrap(~ Model, nrow = 4) +
scale_x_continuous(limits = c(-500,-200))
str(fitK2)
str(fitK2$pgroup)
fitK2$pgroup
str(fitK2$graph)
as_adjacency_matrix(fitK2$graph)
as_adj_edge_list(fitK2$graph)
as_adj(fitK2$graph)
as.numeric(as_adj(fitK2$graph))
dim(as.numeric(as_adj(fitK2$graph)))
str(as.numeric(as_adj(fitK2$graph)))
str(as.numeric(as_adj(fitK2$graph,type = "upper")))
as_adj(fitK2$graph,type = "upper")
as_adj(fitK2$graph,type = "upper",sparse = F)
knitr::opts_chunk$set(echo = TRUE,message = FALSE,warning = FALSE,cache = TRUE)
library(igraph)
library(igraphdata)
library(sbmlogit)
library(sbmlhelpers)
library(ggraph)
library(tidygraph)
library(tidyverse)
data("karate")
fitK2 <- sbmlogit.mcmc(graph = karate,alpha = 2,nsamples = 2000)
# Function for estimator
mp = function(vec, K){
v = rep(1:K)
l = length(vec)
for (i in 1:K){
v[i] = sum(vec==i)/l
}
return(v)
}
SigmaK2 <- fitK2$sample # posterior samples
sigmaK2 <- apply(t(apply(SigmaK2, 2, mp, 2)), 1, which.max) # posterior estimator
scentroidK2 <- sbmlogit.remap(sigmaK2) # remapped posterior estimator
print(scentroidK2)
# function to compute WAIC
# verify this is correct
waic <- function(fit,burn = 0)
{
S <- length(fit$lhood)
ls <- exp(fit$lhood[(burn+1):S])
w <- 2*(log(mean(ls)) - mean(log(ls)))
return(w)
}
fitK3 <- sbmlogit.mcmc(graph = karate,alpha = 3,nsamples = 1000)
fitK4 <- sbmlogit.mcmc(graph = karate,alpha = 4,nsamples = 1000)
fitK5 <- sbmlogit.mcmc(graph = karate,alpha = 5,nsamples = 1000)
waic(fitK2, burn = 100)
waic(fitK3, burn = 100)
waic(fitK4, burn = 100)
waic(fitK5, burn = 100)
lls_df <- as.data.frame(cbind(fitK2$lhood,fitK3$lhood,fitK4$lhood,fitK5$lhood))
colnames(lls_df) <- c("K2","K3","K4","K5")
lls_df <- lls_df %>%
gather(key = "Model", value = "ll")
ggplot(data = lls_df,
aes(x = ll)) +
geom_histogram(bins = 30) +
facet_wrap(~ Model, nrow = 4) +
scale_x_continuous(limits = c(-500,-200))
mean_CRI(fitK2$gamma)
expit <- function(l)
{
return(exp(l)/(1+exp(l)))
}
expit(colMeans(fitK2$eta))
plot_sbmlogit(fitK2, ground = "color")
as_adj(fitK2$graph,type = "upper",sparse = F)
install.packages(c("BayesLogit", "mvtnorm"))
#################################
# Fit logistic regression using #
# Polya-Gamma data Augmentation #
# See Polson et al. (2013)      #
# July 12, 2018                 #
#################################
library(BayesLogit)  # For rpg function
library(mvtnorm)
#################
# Generate Data #
#################
set.seed(071218)
n<-1000
x<-rnorm(n)
beta<-c(-1,1)
X<-cbind(1,x)
p<-ncol(X)
eta<-X%*%beta
phi<-exp(eta)/(1+exp(eta))
y<-rbinom(n,1,phi)
fit<-glm(y~x,family=binomial)
# Priors
beta0<-rep(0,p)   # Prior mean of beta
T0<-diag(.01,p)   # Prior precision of beta
# Inits
beta<-rep(0,p)
#################
# Store Samples #
#################
nsim<-1000                # Number of MCMC Iterations
thin<-1				            # Thinning interval
burn<-nsim/2	            # Burnin
lastit<-(nsim-burn)/thin	# Last stored value
Beta<-matrix(0,lastit,p)
#########
# Gibbs #
#########
tmp<-proc.time()          # Store current time
for (i in 1:nsim){
eta<-X%*%beta
w<-rpg(n,1,eta)
z<-(y-1/2)/w                        # Or define z=y-1/2 and omit w in posterior mean m below
v<-solve(crossprod(X*sqrt(w))+T0)   # Or solve(X%*%W%*%X), where W=diag(w) -- but this is slower
m<-v%*%(T0%*%beta0+t(w*X)%*%z)      # Can omit w here if you define z=y-1/2
beta<-c(rmvnorm(1,m,v))
#################
# Store Results #
#################
if (i> burn & i%%thin==0) {
j<-(i-burn)/thin
Beta[j,]<-beta
}
if (i%%100==0) print(i)
}
proc.time()-tmp             # MCMC run time
# Results
mbeta<-colMeans(Beta)
sbeta<-apply(Beta,2,sd)
# Compare MLEs and
summary(fit)
cat("mbeta","\n",mbeta,"\n","sbeta","\n",sbeta)
# Trace plots
par(mfrow=c(2,1))
plot(1:lastit,Beta[,1],type="l",col="lightgreen")
abline(h=mbeta[1],col="blue4")
plot(1:lastit,Beta[,2],type="l",col="lightgreen")
#################
# Generate Data #
#################
# set.seed(071218)
n<-6
X<-matrix(c(0,1,1,0,0,
1,1,0,1,0,
1,1,0,0,1,
1,0,1,1,0,
1,0,1,0,1,
0,0,0,1,1),
ncol = 4,
nrow = 6,
byrow = TRUE)
#################
# Generate Data #
#################
# set.seed(071218)
n<-6
X<-matrix(c(0,1,1,0,0,
1,1,0,1,0,
1,1,0,0,1,
1,0,1,1,0,
1,0,1,0,1,
0,0,0,1,1),
ncol = 5,
nrow = 6,
byrow = TRUE)
p<-ncol(X)
y<-c(1,0,1,1,0,1)
fit<-glm(y~x,family=binomial)
fit<-glm(y~X,family=binomial)
fit
fit<-glm(y~X-1,family=binomial)
fit
# Priors
beta0<-rep(0,p)   # Prior mean of beta
T0<-diag(.01,p)   # Prior precision of beta
# Inits
beta<-rep(0,p)
#################
# Store Samples #
#################
nsim<-1000                # Number of MCMC Iterations
thin<-1				            # Thinning interval
burn<-nsim/2	            # Burnin
lastit<-(nsim-burn)/thin	# Last stored value
Beta<-matrix(0,lastit,p)
#########
# Gibbs #
#########
tmp<-proc.time()          # Store current time
for (i in 1:nsim){
eta<-X%*%beta
w<-rpg(n,1,eta)
z<-(y-1/2)/w                        # Or define z=y-1/2 and omit w in posterior mean m below
v<-solve(crossprod(X*sqrt(w))+T0)   # Or solve(X%*%W%*%X), where W=diag(w) -- but this is slower
m<-v%*%(T0%*%beta0+t(w*X)%*%z)      # Can omit w here if you define z=y-1/2
beta<-c(rmvnorm(1,m,v))
#################
# Store Results #
#################
if (i> burn & i%%thin==0) {
j<-(i-burn)/thin
Beta[j,]<-beta
}
if (i%%100==0) print(i)
}
proc.time()-tmp             # MCMC run time
# Results
mbeta<-colMeans(Beta)
sbeta<-apply(Beta,2,sd)
# Compare MLEs and
summary(fit)
cat("mbeta","\n",mbeta,"\n","sbeta","\n",sbeta)
runApp()
UKfaculty
help("UKfaculty")
as.undirected(UKfaculty)
data("UKfaculty")
UKfac <- as.undirected(UKfaculty)
class(UKfac)
ggraph(UKfac,layout = "kk") +
geom_node_point(size = 4) +
geom_edge_link(alpha = 0.5)
UKfac %>%
as_tbl_graph()
ggraph(UKfac,layout = "kk") +
geom_node_point(size = 4, aes(color = Group)) +
geom_edge_link(alpha = 0.5)
UKfac <- UKfac %>%
as_tbl_graph() %>%
activate(nodes) %>%
mutate(school = as.factor(Group))
ggraph(UKfac,layout = "kk") +
geom_node_point(size = 4, aes(color = school)) +
geom_edge_link(alpha = 0.5)
ggraph(UKfac,layout = "kk") +
geom_edge_link(alpha = 0.5)
geom_node_point(size = 4, aes(color = school))
ggraph(UKfac,layout = "kk") +
geom_edge_link(alpha = 0.5) +
geom_node_point(size = 4, aes(color = school))
ggraph(UKfac,layout = "kk") +
geom_edge_link(alpha = 0.25) +
geom_node_point(size = 4, aes(color = school))
fitK2 <- sbmlogit.mcmc(UKfac,alpha = 2,nsamples = 2000)
fitK2 <- sbmlogit.mcmc(UKfac,alpha = 2,nsamples = 2000)
fitK3 <- sbmlogit.mcmc(UKfac,alpha = 3,nsamples = 2000)
fitK4 <- sbmlogit.mcmc(UKfac,alpha = 4,nsamples = 2000)
fitK5 <- sbmlogit.mcmc(UKfac,alpha = 5,nsamples = 2000)
waic(fitK2,burn = 1000)
waic(fitK2,burn = 1000)
waic(fitK3,burn = 1000)
waic(fitK2,burn = 1000)
waic(fitK3,burn = 1000)
waic(fitK4,burn = 1000)
fitK2 <- sbmlogit.mcmc(UKfac,alpha = 2,nsamples = 2000)
plot_sbmlogit(fitK2,ground = "school")
fitK2$graph
class(fitK2$graph)
UKfac <- UKfac %>%
as_tbl_graph() %>%
activate(nodes) %>%
mutate(school = as.factor(Group)) %>%
as.igraph()
class(UKfac)
ggraph(UKfac,layout = "kk") +
geom_edge_link(alpha = 0.25) +
geom_node_point(size = 4, aes(color = school))
fitK2 <- sbmlogit.mcmc(UKfac,alpha = 2,nsamples = 2000)
fitK3 <- sbmlogit.mcmc(UKfac,alpha = 3,nsamples = 2000)
fitK4 <- sbmlogit.mcmc(UKfac,alpha = 4,nsamples = 2000)
fitK5 <- sbmlogit.mcmc(UKfac,alpha = 5,nsamples = 2000)
plot_sbmlogit(fitK2,ground = "school")
plot_sbmlogit(fitK3,ground = "school")
plot_sbmlogit(fitK3,ground = "school")
library(devtools)
install_github("carter-allen/sbmlhelpers")
unlink('~/Documents/School/Research/Code/sbmlogit/karate_test_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE,message = FALSE,warning = FALSE,cache = TRUE)
library(igraph)
library(igraphdata)
library(sbmlogit)
library(sbmlhelpers)
library(ggraph)
library(tidygraph)
library(tidyverse)
data("karate")
fitK2 <- sbmlogit.mcmc(graph = karate,alpha = 2,nsamples = 2000)
# Function for estimator
mp = function(vec, K){
v = rep(1:K)
l = length(vec)
for (i in 1:K){
v[i] = sum(vec==i)/l
}
return(v)
}
SigmaK2 <- fitK2$sample # posterior samples
sigmaK2 <- apply(t(apply(SigmaK2, 2, mp, 2)), 1, which.max) # posterior estimator
scentroidK2 <- sbmlogit.remap(sigmaK2) # remapped posterior estimator
print(scentroidK2)
# function to compute WAIC
# verify this is correct
waic <- function(fit,burn = 0)
{
S <- length(fit$lhood)
ls <- exp(fit$lhood[(burn+1):S])
w <- 2*(log(mean(ls)) - mean(log(ls)))
return(w)
}
fitK3 <- sbmlogit.mcmc(graph = karate,alpha = 3,nsamples = 1000)
fitK4 <- sbmlogit.mcmc(graph = karate,alpha = 4,nsamples = 1000)
fitK5 <- sbmlogit.mcmc(graph = karate,alpha = 5,nsamples = 1000)
View(waic)
knitr::opts_chunk$set(echo = TRUE,message = FALSE,warning = FALSE,cache = TRUE)
library(igraph)
library(igraphdata)
library(sbmlogit)
library(sbmlhelpers)
library(ggraph)
library(tidygraph)
library(tidyverse)
data("karate")
fitK2 <- sbmlogit.mcmc(graph = karate,alpha = 2,nsamples = 2000)
# Function for estimator
mp = function(vec, K){
v = rep(1:K)
l = length(vec)
for (i in 1:K){
v[i] = sum(vec==i)/l
}
return(v)
}
SigmaK2 <- fitK2$sample # posterior samples
sigmaK2 <- apply(t(apply(SigmaK2, 2, mp, 2)), 1, which.max) # posterior estimator
scentroidK2 <- sbmlogit.remap(sigmaK2) # remapped posterior estimator
print(scentroidK2)
# function to compute WAIC
# verify this is correct
waic <- function(fit,burn = 0)
{
S <- length(fit$lhood)
ls <- exp(fit$lhood[(burn+1):S])
w <- 2*(log(mean(ls)) - mean(log(ls)))
return(w)
}
fitK3 <- sbmlogit.mcmc(graph = karate,alpha = 3,nsamples = 1000)
fitK4 <- sbmlogit.mcmc(graph = karate,alpha = 4,nsamples = 1000)
fitK5 <- sbmlogit.mcmc(graph = karate,alpha = 5,nsamples = 1000)
waic(fitK2, burn = 100)
waic(fitK3, burn = 100)
waic(fitK4, burn = 100)
waic(fitK5, burn = 100)
lls_df <- as.data.frame(cbind(fitK2$lhood,fitK3$lhood,fitK4$lhood,fitK5$lhood))
colnames(lls_df) <- c("K2","K3","K4","K5")
lls_df <- lls_df %>%
gather(key = "Model", value = "ll")
ggplot(data = lls_df,
aes(x = ll)) +
geom_histogram(bins = 30) +
facet_wrap(~ Model, nrow = 4) +
scale_x_continuous(limits = c(-500,-200))
mean_CRI(fitK2$gamma)
expit <- function(l)
{
return(exp(l)/(1+exp(l)))
}
expit(colMeans(fitK2$eta))
plot_sbmlogit(fitK2, ground = "color")
data("UKfaculty")
UKfac <- as.undirected(UKfaculty)
UKfac <- UKfac %>%
as_tbl_graph() %>%
activate(nodes) %>%
mutate(school = as.factor(Group)) %>%
as.igraph()
ggraph(UKfac,layout = "kk") +
geom_edge_link(alpha = 0.25) +
geom_node_point(size = 4, aes(color = school)) +
theme_void()
fitK2 <- sbmlogit.mcmc(UKfac,alpha = 2,nsamples = 5000)
fitK3 <- sbmlogit.mcmc(UKfac,alpha = 3,nsamples = 5000)
fitK4 <- sbmlogit.mcmc(UKfac,alpha = 4,nsamples = 5000)
fitK5 <- sbmlogit.mcmc(UKfac,alpha = 5,nsamples = 5000)
plot_sbmlogit(fitK2,ground = "school",alpha = 0.25)
plot_sbmlogit(fitK3,ground = "school", alpha = 0.25)
plot_sbmlogit(fitK4,ground = "school", alpha = 0.25)
plot_sbmlogit(fitK5,ground = "school", alpha = 0.25)
waic(fitK2)
waic(fitK3)
waic(fitK4)
waic(fitK5)
fitK2$gamma
dim(fitK4$gamma)
mean_CRI(fitK4$gamma)
apply(fitK4$gamma, 2, mean_CRI)
library(igraph)
library(igraphdata)
library(sbmlogit)
library(sbmlhelpers)
library(ggraph)
library(tidygraph)
library(tidyverse)
library(coda)
install.packages("coda")
library(igraph)
library(igraphdata)
library(sbmlogit)
library(sbmlhelpers)
library(ggraph)
library(tidygraph)
library(tidyverse)
library(coda)
geweke.diag(fitK4$gamma)
geweke.diag(fitK4$gamma[4001:5000,])
shiny::runApp('Code/sbmlogit/SBM3')
knitr::opts_chunk$set(echo = TRUE,message = FALSE,warning = FALSE,cache = TRUE)
library(igraph)
library(igraphdata)
library(sbmlogit)
library(sbmlhelpers)
library(ggraph)
library(tidygraph)
library(tidyverse)
library(coda)
data("karate")
fitK2 <- sbmlogit.mcmc(graph = karate,alpha = 2,nsamples = 2000)
plot_sbmlogit(fitK2)
plot_sbmlogit(fitK2,ground = "color")
p <- plot_sbmlogit(fitK2,ground = "color")
install.packages("plotly")
library(plotly)
ggplotly(p)
p
runApp('Code/sbmlogit/SBM3')
source('~/Documents/School/Research/Code/sbmlogit/plot_sbmlogit.R')
plot_sbmlogit(fitK2)
colMeans(fitK2$eta)
source('~/Documents/School/Research/Code/sbmlogit/plot_sbmlogit.R')
plot_sbmlogit(fitK2)
source('~/Documents/School/Research/Code/sbmlogit/plot_sbmlogit.R')
plot_sbmlogit(fitK2)
plot_sbmlogit(fitK2,ground = "color")
fitK2$graph
v(karate)
V(karate)
source('~/Documents/School/Research/Code/sbmlogit/plot_sbmlogit.R')
plot_sbmlogit(fitK2)
V(karate)
as.character(V(karate))
as.numeric(V(karate))
source('~/Documents/School/Research/Code/sbmlogit/plot_sbmlogit.R')
plot_sbmlogit(fitK2)
plot_sbmlogit(fitK2,ground = "color")
plot_sbmlogit(fitK2)
source('~/Documents/School/Research/Code/sbmlogit/plot_sbmlogit.R')
plot_sbmlogit(fitK2)
source('~/Documents/School/Research/Code/sbmlogit/plot_sbmlogit.R')
plot_sbmlogit(fitK2)
source('~/Documents/School/Research/Code/sbmlogit/plot_sbmlogit.R')
plot_sbmlogit(fitK2)
source('~/Documents/School/Research/Code/sbmlogit/plot_sbmlogit.R')
plot_sbmlogit(fitK2)
plot_sbmlogit(fitK2,ground = "color")
source('~/Documents/School/Research/Code/sbmlogit/plot_sbmlogit.R')
plot_sbmlogit(fitK2)
source('~/Documents/School/Research/Code/sbmlogit/plot_sbmlogit.R')
plot_sbmlogit(fitK2)
View(get_labels)
shiny::runApp('Code/sbmlogit/SBM3')
runApp('Code/sbmlogit/SBM3')
