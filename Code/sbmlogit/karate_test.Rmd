---
title: "Testing sbmlogit package"
author: "Carter Allen"
date: "1/20/2020"
output: 
  html_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message = FALSE,warning = FALSE,cache = TRUE)
```

# To-Do 

- Create plotting functions
- Assess the effect of degree correction (see P & C section 7.2.1)
- Fit models to more test data sets of differing community structure
- Look into model comparison criteria
- Look into model extensions 
- Better understand interpretation of model parameters

# Intro 

Load packages. `igraph` is required, as well as the `C` library version.

```{r}
library(igraph)
library(igraphdata)
library(sbmlogit)
library(sbmlhelpers)
library(ggraph)
library(tidygraph)
library(tidyverse)
```

# Karate Data

Load karate data (an `igraph` object). Note that `sbmlogit` operates on data in the form of `igraph` objects.

```{r}
data("karate")
```

Obtain MCMC samples for $K = 2$ specified clusters. We can specify a two cluster model by setting `alpha = 2`, in which case $K$ is set automatically to 2, and $\alpha$ is set to $\alpha_{K \times 1} = (1/K,...,1/K)^T$. The number of MCMC iterations is controlled with `nsamples`.

```{r}
fitK2 <- sbmlogit.mcmc(graph = karate,alpha = 2,nsamples = 2000)
```

Define the `mp` ("most probable"?) function from P & C (2016), where `apply(Sigma, 2, mp, K)` returns a $K \times N$ matrix, the transpose of which is the ${N \times K}$ matrix $\mathbf{P}$, where $P_{ij}$ is the proportion of MCMC iterations where node $i$ ($i = 1,...,N$) belonged to cluster $j$ ($j = 1,...,K$).

```{r}
# Function for estimator
mp = function(vec, K){
  v = rep(1:K)
  l = length(vec)
  
  for (i in 1:K){
    v[i] = sum(vec==i)/l
  }
  return(v)
}
```

Now, we apply the `which.max()` function to the matrix $\mathbf{P}$ described above to find the most probable cluster membership for each node. The `sbmlogit.remap()` function remaps the posterior estimate of $\boldsymbol\sigma$ to the canonical version described in P & C (2016).

Compute estimators. 

```{r}
SigmaK2 <- fitK2$sample # posterior samples
sigmaK2 <- apply(t(apply(SigmaK2, 2, mp, 2)), 1, which.max) # posterior estimator
scentroidK2 <- sbmlogit.remap(sigmaK2) # remapped posterior estimator
print(scentroidK2)
```

Evaluate model fit with WAIC.

```{r}
# function to compute WAIC
# verify this is correct
waic <- function(fit,burn = 0)
{
    S <- length(fit$lhood)
    ls <- exp(fit$lhood[(burn+1):S])
    w <- 2*(log(mean(ls)) - mean(log(ls)))
    return(w)
}
```

Compare models with varying K. 

```{r,message=FALSE}
fitK3 <- sbmlogit.mcmc(graph = karate,alpha = 3,nsamples = 1000)
fitK4 <- sbmlogit.mcmc(graph = karate,alpha = 4,nsamples = 1000)
fitK5 <- sbmlogit.mcmc(graph = karate,alpha = 5,nsamples = 1000)
```

```{r}
waic(fitK2, burn = 100)
waic(fitK3, burn = 100)
waic(fitK4, burn = 100)
waic(fitK5, burn = 100)
```

Conduct posterior inference for 2-class model. In this case, `fitK2$gamma` contains the posterior samples of $\gamma_{12}$. In general, there are $K \choose 2$ of the $\gamma$ parameters: $\gamma_{12},...,\gamma_{K-1,K}$, since the authors set $\gamma_{11} = \gamma_{22} = ... = \gamma_{KK} = 0$ for identifiability purposes. Below is a summary of the posterior distribution of $\gamma_{12}$ for the two cluster model. 

```{r}
mean_CRI(fitK2$gamma)
```

We can see that the posterior mean and 95\% credible interval for $\gamma_{12}$ are less than 0 -- the intra-community connectivity of the graph enforced by assuming $\gamma_{11} = \gamma_{22} = 0$. Thus, there is significantly less propensity for edges to exist _between_ the two communities than _within_ the two communities. This is indicative of strong assortative community structure. 

The remaining parameters to infer are $\eta_1,...,\eta_{N}$, where $N = 34$ is the number of nodes in the karate graph. Each $\eta_i$ accounts for the expected degree of node $i$ on the logit scale. The authors refer to this as _node correction_ as well as the more common _degree correction_. Thus, $\text{logit}^{-1}(\eta_i)$ is the expected degree of node $i$.

```{r}
expit <- function(l)
{
  return(exp(l)/(1+exp(l)))
}
```

```{r}
expit(colMeans(fitK2$eta))
```

We can see that the nodes with the highest expected degree are the actual "hubs" (i.e., the karate teachers), as the `karate` data are arranged such that the first and the last nodes are the two karate teachers. 

To plot the estimated communities of the graph, we can use the custom function `plot_sbmlogit()`.

```{r}
plot_sbmlogit(fitK2, ground = "color")
```











